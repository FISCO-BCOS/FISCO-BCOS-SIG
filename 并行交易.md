# FISCO BCOS可并行合约

作者：深圳职业技术学院高旭亮

## 前言

FISCO BCOS提供了可并行合约开发框架，让多笔独立的交易能够被同时执行，有效提高硬件资源的利用率，间接提高基于FISCO BCOS的应用的性能瓶颈。本文章参考了FISCO BCOS核心开发者石翔老师的开发可并行性合约文章，添加了作者对可并行合约中一些概念的理解与可并行合约使用经验，补充了石翔老师可行性合约文中未给出的可并行合约基类代码，帮助大家快速理解与上手可并行合约，需要注意的是并行功能非Solidity本身提供，为FISCO BCOS的扩展。

## 正文

### 理论知识

#### 并发并行简介

在说明可并行合约之前，先聊一聊编程中常提的并发并行问题，并发是指有多个线程能够对一个资源进行读写，并行是指有多个线程同时对一个资源进行读写（多CPU才可能同时）。什么时候会出现线程安全问题呢，当然是在多个线程同时写（读不会有线程安全问题）一个**共享资源**（如逃离了函数作用域的变量、JAVA中的静态变量），如当多个线程循环同时对一个数值类型变量进行自增自减操作时，得到的结果很可能是没有**原子性**的，这时候一般解决方法是通过**加锁**的形式来保证共享资源访问的安全。那么Solidity语言没有锁这种机制来保证原子性，自然不能有并行执行函数的情况出现，我们是不是就无法实现并行的执行合约呢，作者在没有看到石翔老师的文章时是十分纳闷的，因为无法并行执行合约的话，一个基于合约的应用的TPS就是由合约的TPS决定的，在FISCO BCOS开发人员设计出可并行合约以后，这个问题就得到了很好的解决（感谢开发人员）。

#### 互斥资源

在此场景下互斥资源指的是**不能被并行读写的资源**，如mapping[key]、全局数组[index]、全局变量，总之，逃离了函数内作用域的资源都为共享资源。那我们能不能够并行读写maping呢，他不是共享资源吗，答案是不并行读写同个key是可以的（如果可以，那么可以肯定的是程序对mapping的操作无法保证原子性），**mapping以key为互斥资源**，FISCO BCOS实现的并行资源访问控制是更细粒度的，作用类似Java的ConcurrentHashMap（Java该类的实现为局部锁定资源，不会完全锁定全部资源），全局数组同理，FISCO BCOS以**数组下标为互斥资源**，原因同mapping（保证操作原子性）。

当我们在FISCO BCOS中调用一个合约里被声明为并行函数且入参为未被互斥的资源时，即可实现并行执行函数。为了大家方便理解，我们来举个例子：作者将其理解为前文提到的局部锁，当我调用可并行函数传入互斥资源0来操作全局数组索引0时，将数组的索引0加锁（互斥）了，如果此后函数调用传入了被锁定（互斥）的资源数组索引0，则只能等待前面对数组索引0的操作结束（结束后释放锁），才可以执行该函数操作数组索引0的交易（即操作互斥资源的时候交易执行变为串行了），但这并不会影响到我们操作全局数组索引1、2、3......的数据，因为这不会导致交易执行失去原子性，所以在数组索引0加锁（互斥）时，我们依旧能够并发执行没有发生互斥的交易。（以上仅为于方便理解，具体代码实现非以上所述）

### 代码实现

**可并行合约基类代码**：

最终调用FISCO BCOS内置**预编译**合约ParallelConfigPrecompiled(0x1006)相关方法

```solidity
pragma solidity ^0.4.25;

contract ParallelConfigPrecompiled
{
    function registerParallelFunctionInternal(address, string, uint256) public returns (int);
    function unregisterParallelFunctionInternal(address, string) public returns (int);    
}

contract ParallelContract
{
    ParallelConfigPrecompiled precompiled = ParallelConfigPrecompiled(0x1006);
    

function registerParallelFunction(string functionName, uint256 criticalSize) public 
{
    precompiled.registerParallelFunctionInternal(address(this), functionName, criticalSize);
}

function unregisterParallelFunction(string functionName) public
{
    precompiled.unregisterParallelFunctionInternal(address(this), functionName);
}

function enableParallel() public;
function disableParallel() public;
}
```
**业务合约**：

业务合约继承ParallelContract，调用registerParallelFunction、unregisterParallelFunction来注册并行方法或注销并行方法，最终会通过FISCO BCOS内置预编译合约ParallelConfigPrecompiled实现注册、注销并行方法。

前面说了那么多互斥资源，那FISCO BCOS能自动判断出我们的传参是不是互斥资源吗？答案是不行的，如果想函数被并行执行，我们需要**手动声明函数的互斥资源**。registerParallelFunction声明互斥资源：参数一为方法名字+互斥的资源，参数二为互斥资源数量，如registerParallelFunction("incrBalance(address)", 1)。需要注意的是当**可并行函数有多个参数时，请优先声明互斥参数，一个方法能不能被并行执行，除了考虑参数是否互斥，还需要没有调用外部合约、其他函数接口**。

**（在近期推出的FISCO BCOS3.0中引入了交易并行冲突分析工具，不再需要手动声明互斥资源）**

```solidity
pragma solidity ^0.4.25;
import "./ParallelContract.sol";

contract ParallelDemo is ParallelContract{
    mapping (address => uint256) public address2balance;
  
function incrBalance(address addr) public{
    address2balance[addr]++;
}

function enableParallel() public{
	// 声明incrBalance为可并行函数，指定互斥资源为address类型，共1个互斥变量
    registerParallelFunction("incrBalance(address)",1);
}

function disableParallel() public{
    unregisterParallelFunction("incrBalance(address)");
}

}
```

### 使用建议

由于可并行合约与业务代码耦合度较低，作者将可并行合约理解为可插拔的，建议开发者专注于合约应用业务本身的开发，在合约应用整体开发完毕后再引入可并行合约，注意在开发过程中把控好互斥资源来最大限度利用并行合约的优点即可。（许多合约的扩展功能都与合约本身应用的耦合度都很低，不需要大幅修改合约代码，如本文的可并行交易，还有合约的可升级）

## 结语

本文主要分享了作者对可并行合约相关的一些概念的理解及一些小经验，本文没有演示对可并行合约的测试，因为FISCO BCOS官方文档https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/transaction_parallel.html 中已有详细的通过JAVA-SDK与FISCO BCOS链对可并行合约的TPS进行测试，并且可并行合约及预编译可并行合约在该文档中都有详细说明。

