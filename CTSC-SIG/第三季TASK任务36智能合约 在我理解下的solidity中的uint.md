​# 第三季TASK任务36智能合约 在我理解下的solidity中的uint

作者：重庆电子工程职业学院 | 向键雄 邓立君

## 前言
整型一般用的比较多，会在各个合约中见到整型的存在，那么这个类型也是学习路上不可或缺的

环境：

remix编译器点我跳转

## 正文
我们在sol中遇得到很多类型为整型的数据，所以我们的sol提供了两种数据类型的整型：

有符号的整数（int）：这里我们就可以理解为正负值的整数

无符号的整数（uint）：无符号整数，这里就是只有正数和0的存在

为了有更好的内存控制sol提供了，int8、int16、int32等、一直到int256的无符号的整型类型

同样我们的无符号整数也是一样，uint8、uint16、uint32......uint256

那么在选择上面我们需要注意的是，0~256位的数据，我们使用uint8就可以了，那么存储有符号的负数到正数的-128~127我们使用int8，根据实际情况我们往上走即可。

有些同学会好奇，这个8、16、32......256是什么意思呢？

这里就是我们的二进制，因为我们的计算机是由0101的代码构成的所以底层存储逻辑就是二进制的，那么这里00000000这个在二进制中代表0,11111111这个在二进制中代表256,心细的同学会发现这个数字的个数是八位，就是这里，所以我们的存储就是这样子存储的

## int与运算符
整数类型支持的运算符有三种比较运算符、位运算符、算数运算符

### 比较运算符

|||||||
|----|-----|-----|-----|---|---|
|<=（小于等于）	|<（小于）|	==（等于）	|!=（不等于）|	>=（大于等于）|	>（大于）|


### 位运算符

||||
|----|----|----|
|&&（与）|	\|\|（或）|	^（异或）	~（位取反）|

### 算数运算符

||||||||||
|-|-|-|-|-|-|-|-|-|
| +	| -	| 一元运算符“-”	| 一元运算符“+”| 	*	| /| 	%| 	**| 	<<	>>|


一遍看下来估计就是左移右移的操作有问题这里解释一下

左移：a << b 可以理解为a乘以2的b次方

右移：a >> b 可以理解为a除以2的b次方

运算符使用方法如下：

- uint256 public _uintNum = 12345; //整数                         结果：12345

- uint256 public _uintNum1 = _uintNum + 1; //加法            结果：12346

- uint256 public _uintNum2 = 2**2; // 指数                          结果：4

- uint256 public _uintNum3 = 7 % 2; //取余                        结果：1

- bool public _boolnum = _ uintNum2 > _uintNum3;//判断 结果： true

### 注意事项

声明方式

int8 a = -1;

uint16 b = 1;

uint c ;

int d ;

整数运算时如果遇到常量就会被截断，如果是常量就不会，常量就是在定义时就有值且不改变的量，如果遇到0的时候是非法的，会报错。

左右位移就是移二进制的位置，现在我们有10000这样一位二进制数换成十进制就是32，那么我们右移就是1000，左移同理

不能进行负以为，就是不能变成负的

负数不能进行指数操作就是“**”

```

pragma solidity ^0.4.23; //表示编译器的版本，^代表大版本为4即可
contract UintTest{ //创建一个合约 自定义合约名为UintTest
uint a = 10; // 定义一个变量a为10
uint b = 2; // 定义一个变量b为2
function getUint() public view returns(uint){// 定义一个函数 函数名为getUint 权限为公共 只读 返回一个uint类型 
uint sum = a ** b + 3 % 2;// 定义一个uint类型使用运算符a的b次方加3取余2最后的结果为101
return sum;// 返回sum
}
}

```


